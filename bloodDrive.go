package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"math"
	"strings"
	"time"

	database "github.com/replit/database-go"
	"golang.org/x/text/language"
	"golang.org/x/text/message"
	//"strconv"
)

const (
	AP  = "A+"
	AN  = "A-"
	BP  = "B+"
	OP  = "O+"
	ON  = "O-"
	ABP = "A/B+"
	ABN = "A/B-"
)
const (
	//Drive types
	IH = "In-House"
	//Mob           = "Mobile"
	TDY = "TDY"
	//Donor pool
	T  = "Training"
	NT = "Non-Training"
	//date-time layouts
	layoutUS      = "January 02, 2006"
	layoutISO     = "2006-01-02"
	shortLayout   = "01/02/2006 15:04"
	Basicfulldate = "Mon Jan 2 3:04:05 MST 2006"
	longForm      = "Jan 2, 2006  3:04PM (MST)"
)

type Tdy struct {
	Kind           string  `bson:"kind"`
	Shipping       float32 `bson:"shipping"`
	FlightCosts    float32 `bson:"flightcosts"`
	AirportParking float32 `bson:"airportparking"`
	Lodging        float32 `bson:"lodging"`
	MEPerDiem      float32 `bson:"perdiem"`
	HotelParking   float32 `bson:"hotelparking"`
}

// func (t Tdy) BeenChanged() bool {
// 	v := t.Shipping + t.FlightCosts + t.AirportParking + t.Lodging + t.MEPerDiem + t.HotelParking
// 	fmt.Println("TDY COSTS\n\n\n", v)
// 	return v >= 0

// }

type InHouse struct {
	Kind                   string  `bson:"kind"`
	CollectionSupplies     float32 `bson:"collectionsupplies"`
	ProcessingSupplies     float32 `bson:"processingsupplies"`
	Testing                float32 `bson:"testing"`
	AverageCivilianRBC     float32 `bson:"averagecivilianRBCost"`
	AverageCivilianFFPpF24 float32 `bson:"averagecivilianFFP"`
}

var BloodDriveDB = map[string]*BloodDrive{}

func getDrive(name string) *BloodDrive {
	y, n := BloodDriveDB[name]
	if n {
		fmt.Println(n)
	}
	return y
}

type BloodDrive struct {
	//*sync.RWMutex
	DriveType DriveType        `bson:"drivetype"`
	Staff     map[string]Staff `bson:"staff"`
	//these values will be generated by a calculation function
	Signature    string   `bson:"signature"`
	creationTime string   `bson:"creationtime"`
	Cost         CostData `bson:"cost"`
}

func (bd BloodDrive) GetStartTime() string {
	return fmt.Sprint(bd.DriveType.Date + " " + bd.DriveType.StartTime)
}

// AVG hours cost
func (bd BloodDrive) GetACH() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsCollecting > 0 {

			hours = append(hours, staff.PayRate)

		}

	}
	for _, v := range hours {
		sum += v
	}
	notNumber := math.IsNaN(float64(math.Round(float64(sum / float32((len(hours)))))))
	if notNumber {
		//fmt.Println("Supporting Hours Cost Average: $", 0.0)

		return 0.0
	} else {
		//fmt.Println("Collections Hours Cost Average: $", sum/float32(len(hours)))
		return float32(math.Round(float64(sum / float32(len(hours)))))
	}

}

func (bd BloodDrive) GetTotalCollectionHours() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsCollecting > 0 {
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, drive.HrsCollecting)

		}

	}
	for _, v := range hours {
		sum += v
	}
	return sum
}

// Average wages per hour for processing blood
func (bd BloodDrive) GetAPH() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsProcessing > 0 {
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, staff.PayRate)

		}

	}
	for _, v := range hours {
		sum += v
	}
	notNumber := math.IsNaN(float64(math.Round(float64(sum / float32((len(hours)))))))
	if notNumber {
		//fmt.Println("Supporting Hours Cost Average: $", 0.0)

		return 0.0
	} else {
		//fmt.Println("Processing Hours Cost Average: $", sum/float32(len(hours)))

		return float32(math.Round(float64(sum / float32((len(hours))))))

	}

}

func (bd BloodDrive) GetTotalProcessingHours() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsProcessing > 0 {
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, drive.HrsProcessing)

		}

	}
	for _, v := range hours {
		sum += v
	}
	return sum
}

func (bd BloodDrive) GetProcessPerPerson() float32 {
	var hours []float32
	var sum float32
	var staffProcessing = 0
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsProcessing > 0 {
			staffProcessing += 1
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, drive.HrsProcessing)

		}

	}
	for _, v := range hours {
		sum += v
	}

	notNumber := math.IsNaN(float64(math.Round(float64(sum / float32((len(hours)))))))
	if notNumber {
		//fmt.Println("processing Hours Cost Average: $", 0.0)

		return 0.0
	}
	avghrs := (sum / float32(staffProcessing))
	return float32(bd.DriveType.WholeBloodCount.Total) / float32(staffProcessing) / avghrs

}

// hours
func (bd BloodDrive) SetPH() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsProcessing > 0 {
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, drive.HrsProcessing)

		}

	}
	for _, v := range hours {
		sum += v
	}
	notNumber := math.IsNaN(float64(math.Round(float64(sum / float32((len(hours)))))))
	if notNumber {
		//fmt.Println("Supporting Hours Cost Average: $", 0.0)

		return 0.0
	} else {
		//fmt.Println("Processing Hours Cost Average: $", sum/float32(len(hours)))
		bd.DriveType.ProcessingHours = float32(math.Round(float64(sum / float32(len(hours)))))
		return float32(math.Round(float64(sum / float32((len(hours))))))

	}

}

// Avg hours
func (bd BloodDrive) GetASH() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsSupporting > 0 {
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, staff.PayRate)

		}

	}
	for _, v := range hours {
		sum += v
	}
	notNumber := math.IsNaN(float64(math.Round(float64(sum / float32((len(hours)))))))
	if notNumber {
		//fmt.Println("Supporting Hours Cost Average: $", 0.0)

		return 0.0
	} else {
		//fmt.Println("Supporting Hours Cost Average: $", sum/float32(len(hours)))
		return float32(math.Round(float64(sum / float32((len(hours))))))
	}

}

func (bd BloodDrive) GetTotalSupportHours() float32 {
	var hours []float32
	var sum float32
	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]

		if drive.HrsSupporting > 0 {
			//fmt.Println("collections: ",v, v.HrsCollecting)
			hours = append(hours, drive.HrsSupporting)

		}

	}
	for _, v := range hours {
		sum += v
	}
	return sum
}

func (bd BloodDrive) GetTotalStaffHours() float32 {
	return bd.GetTotalCollectionHours() + bd.GetTotalProcessingHours() + bd.GetTotalSupportHours()
}

func (bd *BloodDrive) addStaff(staff Staff, updateId int, cent DonorCenter) (error, Staff) {
	Lock.Lock()
	if _, ok := bd.Staff[staff.Name]; ok {

		return errors.New("Staff already added"), staff
	}

	//dhw := DriveHoursWorked{}
	staff.addDrive(bd.DriveType.Date + " " + bd.DriveType.StartTime)
	bd.Staff[staff.Name] = staff
	Lock.Unlock()

	centerDB, _ := json.Marshal(c)
	database.Set("all", string(centerDB))

	update(updateId, cent)

	//addStaffToDrive(bd,)
	return nil, staff

}

func (bd *BloodDrive) removeStaff(staff Staff, updateId int, cent DonorCenter) {
	Lock.Lock()
	delete(staff.DriveHours, bd.DriveType.Date+" "+bd.DriveType.StartTime)
	delete(bd.Staff, staff.Name)
	//delete(cent.StaffList[staff.Name].DriveHours, bd.DriveType.Date+" "+bd.DriveType.StartTime)
	//staff.removeDrive(bd.DriveType.Date + " " + bd.DriveType.StartTime)
	//delete(staff.DriveHours, bd.DriveType.Date+" "+bd.DriveType.StartTime)

	Lock.Unlock()
	c.Centers[cent.Num] = cent
	fmt.Println("DELETED HOURS OF: ", staff)

	centerDB, _ := json.Marshal(c)
	database.Set("all", string(centerDB))

	update(updateId, cent)
	return
}

func createDrive(drivetype, signature, when, start string, center int) BloodDrive {

	newdate := strings.Split(GetDateTime(), " ")[0]
	fmt.Println("this is the new date", newdate)
	//create the drive
	fmt.Println("THIS IS WHEN: ", when)
	drive := BloodDrive{
		Signature: signature,
		DriveType: DriveType{
			Kind:            drivetype,
			Date:            when,
			StartTime:       start,
			WholeBloodCount: WholeBlood{},
			Comments:        []Comment{},
		},
		Staff:        make(map[string]Staff),
		creationTime: newdate,
		Cost:         CostData{
			//TDY: Tdy{Report: report},
		},
	}

	cent := c.Centers[center]

	Lock.Lock()
	drive.Cost.InHouse = cent.Default.Inhouse

	if drive.DriveType.Kind == TDY {
		drive.Cost.BeenChanged = false
	}
	// Set the Type variable based on drivetype
	if drive.DriveType.Kind == "TDY" {
		//report.Type = TDY
	}

	if cent.BloodDrives == nil {
		cent.BloodDrives = make(map[string]BloodDrive)
	}

	//TODO: write a test to see if the drive already exists
	_, ok := cent.BloodDrives[drive.DriveType.Date+" "+drive.DriveType.StartTime]
	if ok {
		fmt.Println("drive already exists, it will not be recreated")
		return drive
	}
	if !ok {
		cent.BloodDrives[drive.DriveType.Date+" "+drive.DriveType.StartTime] = drive

		fmt.Println("just created a drive in :", cent.Name, " Here it is:  ", drive)
	}
	//modifyOne(cent)
	Lock.Unlock()
	c.Centers[center] = cent

	centerDB, _ := json.Marshal(c)
	database.Set("all", string(centerDB))

	update(cent.Num, cent)

	return drive
}

func deleteDrive(datetime string, center int) {
	cent := c.Centers[center]
	Lock.Lock()
	fmt.Println("getting drive now.......")
	drive := cent.BloodDrives[datetime]

	//Check if any staff member has recorded hours for the specified drive
	for _, staff := range cent.StaffList {
		if hours, ok := staff.DriveHours[datetime]; ok {
			fmt.Printf("Staff member has recorded %.2f hours for drive at %s. Drive cannot be deleted.\n", hours, datetime)
			Lock.Unlock()
			return
		}
	}
	for _, v := range drive.Staff {
		delete(v.DriveHours, datetime)
	}
	for _, staff := range cent.StaffList {
		delete(staff.DriveHours, datetime)
		//GetDriveHoursValues(staff)

		break
	}

	fmt.Println("deleting drive now .......")
	delete(cent.BloodDrives, datetime)

	Lock.Unlock()
	c.Centers[center] = cent

	centerDB, _ := json.Marshal(c)
	database.Set("all", string(centerDB))

	update(center, c.Centers[center])
	return
}

type CostData struct {
	EnteredBy   string  `bson:"enteredby"`
	TDY         Tdy     `bson:"tdy"`
	InHouse     InHouse `bson:"inhouse"`
	BeenChanged bool    `bson:"changed"`
}

type CreationTime struct {
	DateTime string `bson:"datetime"`
}

func GetDateTime() string {
	t := time.Now()
	return t.Local().Format(shortLayout)
}

type Location struct {
	Facility        string `bson:"facility"`
	WhereonFacility string `bson:"whereonfacility"`
}
type Comment struct {
	Notes     string `bson:"notes"`
	Date      string `bson:"date"`
	Signature string `bson:"signature"`
	ID        int64  `bson:"id"`
}

func (bd *BloodDrive) addComment(notes, sig string, centernum int) string {
	center := c.Centers[centernum]
	// drivedate:=req.FormValue("drive-date")
	if notes == "" {
		return "comment cannot be empty"

	}
	comment := Comment{
		Notes:     notes,
		Date:      GetDateTime(),
		Signature: sig,
		ID:        int64(len(bd.DriveType.Comments)),
	}
	Lock.Lock()
	bd.DriveType.Comments = append(bd.DriveType.Comments, comment)

	center.BloodDrives[bd.DriveType.Date+" "+bd.DriveType.StartTime] = *bd
	//fmt.Println("\n\n\n\\look here", bd)
	Lock.Unlock()

	centerDB, _ := json.Marshal(c)
	database.Set("all", string(centerDB))

	update(centernum, c.Centers[centernum])
	return "success"

}

func (bd *BloodDrive) editComment(notes string, id int64) string {
	if notes == "" {
		return "comment cannot be empty"

	}
	comment := bd.DriveType.Comments[id]
	comment.Notes = notes
	bd.DriveType.Comments[id] = comment
	return fmt.Sprintln("comment has been edited for drive date: ", bd.DriveType.Date)

}

type DriveType struct {
	Kind                  string     `bson:"kind"` // kind should be either tdy or in house
	Location              string     `bson:"location"`
	Date                  string     `bson:"date"`
	DonorPool             string     `bson:"donorPool"`
	DriveLength           float32    `bson:"drivelength"`
	NumOfRegisteredDonors int        `bson:"numberofregistereddonors"`
	DeferredDonors        int        `bson:"deferreddonors"`
	WholeBloodCount       WholeBlood `bson:"wholebloodcount"`
	StartTime             string     `bson:"starttime"`
	ProcessingHours       float32    `bson:"processinghours"` //average for person
	NumOfFFPPF24          int        `jbon:"numofffppf24"`
	TravelSetupTeardown   float32    `bson:"travelsetupteardown"`
	Signature             string     `bson:"signature"`
	Comments              []Comment  `bson:"comments"`
}

type WholeBlood struct {
	OPositive, ONegative, APositive, ANegative, BPositive, BNegative, ABPositive, ABNegative int
	Total                                                                                    int
}

func (wb WholeBlood) GetTotal() int {

	return wb.OPositive + wb.ONegative + wb.ANegative + wb.ABPositive + wb.BPositive + wb.BNegative + wb.APositive + wb.ABNegative
}

func (dc *DonorCenter) editDrive(date string) BloodDrive {
	bd := dc.BloodDrives[date]
	//do something here
	return bd
}

// Total amount of wages for supporting the drive
func (bd BloodDrive) GetTotalSupport() float32 {
	var total float32
	var hours []float32

	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]
		if drive.HrsSupporting > 0 {

			hours = append(hours, staff.PayRate*drive.HrsSupporting)

		}

	}

	for _, v := range hours {
		total += v
	}
	//fmt.Println("this is the total support wages:$ ", total)
	return total
}

// Total amount of wages for collecting blood
func (bd BloodDrive) GetTotalCollecting() float32 {
	var total float32
	var hours []float32

	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]
		if drive.HrsCollecting > 0 {

			hours = append(hours, staff.PayRate*drive.HrsCollecting)

		}

	}

	for _, v := range hours {
		total += v
	}
	//fmt.Println("this is the total blood collection wages:$ ", total)
	return total
}

// Total amount of wages for processing blood
func (bd BloodDrive) GetTotalProcessing() float32 {
	var total float32
	var hours []float32

	for _, staff := range bd.Staff {
		drive := staff.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime]
		if drive.HrsProcessing > 0 {

			hours = append(hours, staff.PayRate*drive.HrsProcessing)

		}

	}

	for _, v := range hours {
		total += v
	}
	//fmt.Println("this is the total supporting wages:$ ", total)
	return total
}

// Total amount of wages for all staff
func (bd BloodDrive) GetWagesTotal() float32 {
	return bd.GetTotalSupport() + bd.GetTotalCollecting() + bd.GetTotalProcessing()
}

// Total cost of collection supplies
func (bd BloodDrive) GetCollectionSuppliesTotal() float32 {
	//fmt.Println("collection:supplies cost", bd.Cost.InHouse.CollectionSupplies*float32(bd.DriveType.WholeBloodCount.Total))
	return bd.Cost.InHouse.CollectionSupplies * float32(bd.DriveType.WholeBloodCount.Total)
}

// Total cost of processing supplies
func (bd BloodDrive) GetProcessingSuppliesTotal() float32 {
	//fmt.Println("processing:supplies cost", bd.Cost.InHouse.ProcessingSupplies*float32(bd.DriveType.WholeBloodCount.Total))
	return bd.Cost.InHouse.ProcessingSupplies * float32(bd.DriveType.WholeBloodCount.Total)
}

// Total cost of testing supplies
func (bd BloodDrive) GetTestingSuppliesTotal() float32 {
	//fmt.Println("testing:supplies cost", bd.Cost.InHouse.Testing*float32(bd.DriveType.WholeBloodCount.Total))
	return bd.Cost.InHouse.Testing * float32(bd.DriveType.WholeBloodCount.Total)
}

// Total cost of all supplies
func (bd BloodDrive) GetSuppliesTotal() float32 {
	return bd.GetProcessingSuppliesTotal() + bd.GetProcessingSuppliesTotal() + bd.GetTestingSuppliesTotal()
}

// Total cost of travel
func (bd BloodDrive) GetTotalTravel() float32 {
	//fmt.Println("total:travel cost", bd.Cost.TDY.AirportParking+bd.Cost.TDY.Lodging+bd.Cost.TDY.FlightCosts+bd.Cost.TDY.HotelParking+bd.Cost.TDY.MEPerDiem)
	return bd.Cost.TDY.AirportParking + bd.Cost.TDY.Lodging + bd.Cost.TDY.FlightCosts + bd.Cost.TDY.HotelParking + bd.Cost.TDY.MEPerDiem
}

// Total cost of all expenses
func (bd BloodDrive) GetTotalExpenses() float32 {
	supplies := bd.GetCollectionSuppliesTotal() + bd.GetProcessingSuppliesTotal() + bd.GetTestingSuppliesTotal()
	wages := bd.GetTotalCollecting() + bd.GetTotalProcessing() + bd.GetTotalSupport()
	travel := bd.GetTotalTravel()
	shipping := bd.Cost.TDY.Shipping

	return supplies + wages + travel + shipping
}

// Total cost of all transportation this includes shipping and travel
func (bd BloodDrive) GetTransportTotal() float32 {
	return bd.GetTotalTravel() + bd.Cost.TDY.Shipping
}

// Cost per unit of blood if purchased at civilian rates
func (bd BloodDrive) GetCostPerUnit() float32 {
	wbt := bd.DriveType.WholeBloodCount.Total
	texp := bd.GetTotalExpenses()

	notNumber := math.IsNaN(float64(texp / float32(wbt)))
	if notNumber {

		return 0.0
	} else {

		return texp / float32(wbt)
	}
}

// Whole Blood Units Collected Per Hour
func (bd BloodDrive) GetUnitsCollectedPerHr() float32 {
	tot := bd.DriveType.WholeBloodCount.GetTotal()
	count := bd.DriveType.DriveLength

	notNumber := math.IsNaN(float64(float32(tot) / count))
	if notNumber {

		return 0.0
	} else {

		rv := float32(tot) / count
		return float32(math.Round(float64(rv)))
	}

}

// Whole Blood Units Collected Per Person
func (bd BloodDrive) GetUnitsPerPerson() float32 {
	return bd.GetUnitsCollectedPerHr() / float32(len(bd.Staff))
}

// Cost to buy RBC at civilian rates
func (bd BloodDrive) GetCostToBuyRBC() float32 {
	rbc := bd.Cost.InHouse.AverageCivilianRBC * float32(bd.DriveType.WholeBloodCount.Total)

	return rbc
}

// Cost to buy FFP at civilian rates
func (bd BloodDrive) GetCostToBuyFFP() float32 {
	ffp := bd.Cost.InHouse.AverageCivilianFFPpF24 * float32(bd.DriveType.WholeBloodCount.Total)
	return ffp
}

// Cost avoidance is the difference between the cost to buy blood at civilian rates and the cost to collect blood in house
func (bd BloodDrive) GetCostAvoidance() float32 {
	totalexpenses := bd.GetTotalExpenses()
	rbc := bd.GetCostToBuyRBC()
	ffp := bd.Cost.InHouse.AverageCivilianFFPpF24 * float32(bd.DriveType.WholeBloodCount.Total)
	sum := rbc + ffp

	return sum - totalexpenses

}

// ThousandsPrinter formats a number with a comma as a thousands separator
func (bd BloodDrive) ThousandsPrinter(number float32) string {
	p := message.NewPrinter(language.English)
	withCommaThousandSep := p.Sprintf("%.2f", number)

	return withCommaThousandSep
}

// PassOrFail is a struct that holds a color and a number representing a percentage and a color indicating pass or fail
type passOrFail struct {
	Color  string  `bson:"color"`
	Number float64 `bson:"number"`
}

// GetActualDonors returns the number of donors who actually donated blood
func (bd BloodDrive) GetActualDonors() int {
	return bd.DriveType.NumOfRegisteredDonors - bd.DriveType.DeferredDonors

}

// GetPercentage returns a passOrFail struct with a color and a number
func (bd BloodDrive) GetPercentage() passOrFail {
	// te:=bd.GetTotalExpenses()
	// rbc:=bd.Cost.InHouse.AverageCivilianRBC*float32(bd.DriveType.WholeBloodCount.Total)
	// ffp:=bd.Cost.InHouse.AverageCivilianFFPpF24*float32(bd.DriveType.WholeBloodCount.Total)
	// sum:=rbc+ffp
	// percentage:=(te/sum)
	pf := passOrFail{}

	cp := bd.GetCostPerUnit()
	civCost := bd.Cost.InHouse.AverageCivilianRBC

	topvalue := civCost - cp
	bottomvalue := civCost + cp/2
	percentage := topvalue / bottomvalue
	notNumber := math.IsNaN(float64(percentage))

	if notNumber {
		pf.Number = 0.0
		pf.Color = "yellow"

	}

	Negative := math.IsInf(float64(percentage), -0)

	if Negative {
		pf.Number = 0.0
		pf.Color = "orange"
	}

	if percentage < 0.20 && percentage > 0.1 {
		pf.Color = "yellow"
		pf.Number = float64(zeroOut(float64(percentage)))
	}

	if percentage >= 0.20 {
		pf.Color = "green"
		pf.Number = float64(zeroOut(float64(percentage)))
	}
	if pf.Number > 1.5 {
		pf.Color = "orange"
		pf.Number = 50.00
	}

	if pf.Number <= 0.0 || bd.GetCostAvoidance() <= -0.01 {
		pf.Number = 0.0
		pf.Color = "red"
	}
	fmt.Println("PERCENTAGE", percentage)
	return pf
}

// isFinite checks if a number is finite
func isFinite(num float64) bool {
	return math.IsInf(num, 1)
}

// Float2String converts a float to a string
func (bd BloodDrive) Float2String(xF float64) string {

	str := fmt.Sprintf("%.2f", xF)
	str = strings.Split(str, ".")[1]

	return str

}

// WhoDidWhat returns a struct with the number of staff who did what
func (bd BloodDrive) WhoDidWhat() interface{} {
	var p, c, s int
	for _, v := range bd.Staff {
		if v.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime].HrsProcessing > 0 {
			p += 1
		}
		if v.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime].HrsCollecting > 0 {
			c += 1
		}
		if v.DriveHours[bd.DriveType.Date+" "+bd.DriveType.StartTime].HrsSupporting > 0 {
			s += 1
		}
	}

	//object is a struct containing the totals for each category
	object := struct {
		Supporting int
		Collecting int
		Processing int
	}{s, c, p}

	return object
}

// GenerateReport returns a struct with the totals and averages for the blood drive. All values are related to cost, so regard them as dollar amounts
func (bd BloodDrive) GenerateReport() interface{} {
	report := struct {
		TotalDonors         int        `json:"totalDonors"`
		TotalUnits          float32    `json:"totalUnits"`
		TotalExpenses       float32    `json:"totalExpenses"`
		TotalWages          float32    `json:"totalWages"`
		TotalSupplies       float32    `json:"totalSupplies"`
		TotalTravel         float32    `json:"totalTravel"`
		TotalCost           float32    `json:"totalCost"`
		CostIfPurchasedRBC  float32    `json:"costIfPurchasedRBC"`
		CostIfPurchasedFFP  float32    `json:"costIfPurchasedFFP"`
		TotalCostAvoidance  float32    `json:"totalCostAvoidance"`
		TotalUnitsPerHr     float32    `json:"totalUnitsPerHr"`
		TotalUnitsPerPerson float32    `json:"totalUnitsPerPerson"`
		TotalCostPerUnit    float32    `json:"totalCostPerUnit"`
		APH                 float32    `json:"aph"`
		ACH                 float32    `json:"ach"`
		DriveScore          passOrFail `json:"driveScore"`
		DateTime            string     `json:"dateTime"`
	}{
		TotalDonors:         bd.GetActualDonors(),
		TotalUnits:          zeroOut(float64(bd.DriveType.WholeBloodCount.Total)),
		TotalExpenses:       zeroOut(float64(bd.GetTotalExpenses())),
		TotalWages:          zeroOut(float64(bd.GetWagesTotal())),
		TotalSupplies:       zeroOut(float64(bd.GetSuppliesTotal())),
		TotalTravel:         zeroOut(float64(bd.GetTotalTravel())),
		TotalCost:           zeroOut(float64(bd.GetTotalExpenses())),
		CostIfPurchasedRBC:  zeroOut(float64(bd.GetCostToBuyRBC())),
		CostIfPurchasedFFP:  zeroOut(float64(bd.GetCostToBuyFFP())),
		TotalCostAvoidance:  zeroOut(float64(bd.GetCostAvoidance())),
		TotalUnitsPerHr:     zeroOut(float64(bd.GetUnitsCollectedPerHr())),
		TotalUnitsPerPerson: zeroOut(float64(bd.GetUnitsPerPerson())),
		TotalCostPerUnit:    zeroOut(float64(bd.GetCostPerUnit())),
		APH:                 zeroOut(float64(bd.GetAPH())),
		ACH:                 zeroOut(float64(bd.GetACH())),
		DriveScore:          bd.GetPercentage(),
		DateTime:            bd.DriveType.Date + " " + bd.DriveType.StartTime,
	}
	return report
}

// zeroOut checks if a number is infinite or NaN and returns 0.0 if it is
func zeroOut(inf float64) float32 {
	if math.IsInf(inf, -0) || math.IsNaN(inf) {
		return 0.0
	} else {
		return float32(inf)

	}
}


